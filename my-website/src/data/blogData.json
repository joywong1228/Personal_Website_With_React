[
  {
    "id": "personal-website",
    "title": "Personal Website with React",
    "skills": ["React", "Vercel", "CSS", "UI/UX"],
    "previewImg": "/projectimg/website-preview.png",
    "published": "2025-06-15",
    "techStack": "React, Vercel, CSS, UI/UX",
    "duration": "3 weeks for current MVP",
    "startDate": "2025-07-17",
    "endDate": "",
    "intro": "Rebuilding my personal website using React.",
    "introDetail": "Building a new personal website to better showcase my skills and projects. My old static HTML page was hard to maintain, limited in design, and looked outdated. I wanted to apply what I learned from recent semesters to make something modern, with easier content updates and a better personal brand.",
    "goal": "Apply Vercel and Firebase",
    "goalDetail": [
      "1. Make a site that’s easy to update, mobile friendly, and visually engaging.",
      "2. Learn React best practices and real deployment workflow.",
      "3. Switch from static HTML to maintainable, modular code.",
      "4. Use Vercel for hosting and deployment.",
      "5. Use Firebase for blog content management.",
      "6. Implement dark mode and responsive design."
    ],
    "motivation": "Upgrade outdated portfolio.",
    "motivationDetail": "My old static HTML page was deployed before my first semester start. I wasn't really know anything about HTML and etc. So i used someone else's template. After learning React, I wanted to rebuild it to reflect my current skills and projects. I also wanted to learn how to deploy a React app properly, using Vercel for hosting and Firebase for dynamic content management.",
    "challenge": "Debugging blank page from a broken icon import, Vercel asset issues.",
    "challenges": [
      {
        "title": "Debugging Silent Failures",
        "details": [
          {
            "number": 1,
            "text": "Some bugs were difficult to track down due to lack of console error messages."
          },
          {
            "number": 2,
            "text": "UI elements not rendering correctly without any exceptions."
          },
          {
            "number": 3,
            "text": "The page appeared blank after importing the Firebase system. And it is hard to debug because there is no error message"
          }
        ],
        "methods": [
          {
            "number": 1,
            "text": "Use thorough manual UI testing to spot visual issues."
          },
          {
            "number": 2,
            "text": "Add extensive logging and use breakpoints for runtime inspection."
          },
          {
            "number": 3,
            "text": "Implement fallback UI and error boundaries in React."
          },
          {
            "number": 4,
            "text": "Add a lot of  try-catch blocks to inspect the console and discovered that the issue was caused by an incorrect icon import."
          }
        ]
      },
      {
        "title": "Deployment Quirks on Vercel",
        "details": [
          {
            "number": 1,
            "text": "Routing errors due to Vercel configuration differences."
          },
          {
            "number": 2,
            "text": "The redeployment process was kept falling after adding the firebase system. "
          }
        ],
        "methods": [
          {
            "number": 1,
            "text": "Carefully structure assets between public and src folders."
          },
          {
            "number": 2,
            "text": "Use Vercel configuration files to control routing behavior."
          },
          {
            "number": 3,
            "text": "Test deployment thoroughly before final release."
          }
        ]
      },
      {
        "title": "Firebase Cloud Functions",
        "details": [
          {
            "number": 1,
            "text": "Firebase configuration keys do not load correctly from .env.local, but work when hardcoded directly in firebase.js."
          },
          {
            "number": 2,
            "text": "Data fetching from Firebase is inconsistent or fails intermittently."
          },
          {
            "number": 3,
            "text": "Data fails to save properly to the Firebase cloud database."
          }
        ],
        "methods": [
          {
            "text": "Environment variables prefixed with NEXT_PUBLIC_ were not working properly in my setup because Next.js expects those variables to be available at build time, but in my development environment or deployment process, they were not being injected correctly. This caused the Firebase config to be incomplete or undefined, leading to errors. Switching to using VITE_FIREBASE_API_ prefix and accessing variables via import.meta.env.VITE_FIREBASE_API_KEY (a Vite environment variable convention) solved the problem because my project was using Vite or a similar bundler that reads environment variables at runtime through import.meta.env, ensuring proper injection and availability. Also, implement error handling and confirm write permissions in Firestore rules; use transaction or batch writes for reliable cloud saving."
          }
        ]
      },
      {
        "title": "Ongoing Feature Updates",
        "details": [
          {
            "number": 1,
            "text": "Continuously adding new ideas like dark mode and additional pages."
          },
          {
            "number": 2,
            "text": "Ensuring backward compatibility while adding features."
          },
          {
            "number": 3,
            "text": "Managing technical debt during frequent updates."
          }
        ],
        "methods": [
          {
            "number": 1,
            "text": "Use feature flags to control new features without breaking existing functionality."
          },
          {
            "number": 2,
            "text": "Follow semantic versioning to track changes and updates."
          },
          {
            "number": 3,
            "text": "Maintain a changelog to document changes and updates."
          }
        ]
      }
    ],
    "insights": "React/JSON makes updates fast, deploying motivates better documentation.",
    "insightsDetail": [
      "Building from scratch is much easier with React than old static HTML",
      "Real hosting (Vercel) motivates better code and documentation",
      "JSON-driven content (for blogs, menus, etc.) makes updates much faster"
    ],
    "next": "Add languages, animations, and interactive demos.",
    "nextDetail": [
      "Add multi-language support for global visitors",
      "Improve animations and section transitions",
      "Integrate more interactive elements (e.g., live projects, demo links)"
    ],
    "finalThoughts": "Rebuilding my site showed me how far I’ve come as a developer.",
    "finalThoughtsDetail": "Rebuilding my personal website using React and deploying it on Vercel has been both a challenging and rewarding experience. It pushed me to deepen my understanding of modern web development concepts such as CSS variables for theming, React hooks like useState and useEffect, and efficient deployment workflows. This project not only reflects my growth as a developer but also lays a strong foundation for future enhancements, including dynamic features and improved user experience. I look forward to continuously iterating on this work and expanding my skills further.",
    "links": [
      {
        "label": "Source on GitHub",
        "url": "https://github.com/joywong1228/Personal_Website_With_React"
      },
      {
        "label": "Original HTML Version",
        "url": "https://first-personal-website-nu.vercel.app"
      }
    ],
    "liveDemo": "https://personal-website-with-react-sigma.vercel.app"
  },
  {
    "id": "astro-tracker",
    "title": "AstroTracker – A Minimalist Mobile Star Map",
    "skills": ["React Native", "Expo", "SVG", "Astronomy"],
    "previewImg": "/projectimg/astrotracker.jpeg",
    "published": "2025-05-22",
    "techStack": "React Native (Expo), react-native-svg, expo-location",
    "duration": "Ongoing (MVP in ~3 days)",
    "startDate": "2025-05-22",
    "endDate": "2025-05-25",
    "liveDemoNote": "Sorry, this blog is currently incomplete. I am focusing on adding all my projects first, then I will update the blog content.",
    "liveDemo": "https://www.youtube.com/embed/W07PNTssnYM",
    "intro": "A simple, offline star map built with React Native and Expo.",
    "introDetail": "AstroTracker is my first step into building a mobile astronomy tool that’s simple, educational, and completely offline. Most stargazing apps feel bloated or locked behind paywalls, so I decided to make my own lightweight, open alternative.",
    "goal": "Visualize real stars/constellations using live device location.",
    "goalDetail": [
      "Build a lightweight star map that works offline",
      "Use the device’s location to plot visible stars from Earth",
      "Draw constellations and stars using react-native-svg"
    ],
    "motivation": "Wanted a hands-on way to combine coding and astronomy.",
    "motivationDetail": "As someone fascinated by space and new to mobile dev, I wanted a project that blended both. Most apps just dump facts—I wanted to *visualize* the sky, and learn React Native in the process.",
    "challenge": "Celestial projection, SVG layout, navigation quirks.",
    "challengeDetail": [
      "RA/Dec projection: Mapping celestial coordinates to 2D screens isn’t trivial",
      "Device location: Permission handling, accuracy, and live rendering"
    ],
    "insights": "MVPs are more satisfying, and React Native is powerful.",
    "insightsDetail": [
      "Small, focused MVPs are more satisfying than big, vague ideas",
      "Astronomy data is surprisingly accessible (Hipparcos, Tycho-2 are public!)"
    ],
    "next": "Add zoom, constellation lines, camera overlay.",
    "nextDetail": [
      "Dynamic star projection (use time & observer heading)",
      "Zoom and pan controls for SVG sky"
    ],
    "finalThoughts": "Already rewarding: code, design, and learning in one project.",
    "finalThoughtsDetail": "AstroTracker is still early, but already a rewarding blend of math, design, and dev. If you’re curious about space, React Native, or just want to follow the stars, this project is for you. ⭐ You don’t need an API key to look at the sky.",
    "links": [
      {
        "label": "Source on GitHub",
        "url": "https://github.com/joywong1228/astrotracker"
      }
    ],
    "challenges": [
      {
        "title": "Celestial Projection Challenges",
        "details": [
          "Mapping celestial coordinates to 2D screens is complex.",
          "Requires understanding of RA/Dec and coordinate transformations."
        ],
        "methods": [
          "Use mathematical libraries for astronomical projections.",
          "Test with real star catalog data to ensure accuracy."
        ]
      },
      {
        "title": "Location Permission and Accuracy",
        "details": [
          "Managing device permission dialogs and fallback UI.",
          "Handling inaccurate or delayed location data gracefully."
        ],
        "methods": [
          "Request permissions at appropriate times with user context.",
          "Implement location fallbacks and error states in UI."
        ]
      }
    ]
  },
  {
    "id": "ai-closet-style",
    "title": "AI Closet Style – GPT-4 Outfit Generator for Fashion Apps",
    "skills": ["Express", "TypeScript", "OpenAI GPT-4 API", "Render", "Expo"],
    "previewImg": "/projectimg/Ai-closet.jpeg",
    "published": "2025-07-18",
    "techStack": "Express, TypeScript, OpenAI GPT-4 API, Render (backend), Expo (frontend)",
    "duration": "1 week for backend, integrated into ongoing mobile app project",
    "startDate": "2025-06-18",
    "endDate": "2025-06-20",
    "intro": "AI Closet Style is my attempt to bring real-time, creative AI to everyday fashion.",
    "introDetail": "The idea: press a button in your closet app and instantly see five fresh, on-trend outfit ideas—each generated by GPT-4, complete with style names, descriptions, and DALL·E image prompts. The backend is a lightweight Express API, ready for cloud deployment and secure enough to keep my OpenAI key safe from users.",
    "goal": "Connect my mobile app to GPT-4 for truly 'AI-powered' fashion ideas.",
    "goalDetail": [
      "Connect my mobile app to GPT-4 for truly “AI-powered” fashion ideas",
      "Get 5 new, catchy outfit style cards every time I refresh",
      "Make it shareable: anyone with the app can get ideas, from anywhere",
      "Keep my OpenAI key secure with a cloud backend (not exposed in the app)",
      "Simple, fast, and cheap to run—free Render plan!"
    ],
    "motivation": "Wanted something more inspiring and dynamic than usual wardrobe apps.",
    "motivationDetail": "I love minimalist wardrobe apps, but most just cycle through the same old “casual,” “preppy,” or “date night” tags. I wanted something more inspiring and dynamic—outfit ideas that change every day, sometimes pastel, sometimes bold, sometimes a little weird (in a good way). Plus, it was a fun way to learn OpenAI API and backend deployment beyond the usual web demos.",
    "projectStructure": "/backend\n  ├─ index.ts              → Express API: POST /api/get-style-ideas\n  ├─ package.json          → scripts, dependencies, start/build commands\n  ├─ tsconfig.json         → TypeScript config\n  ├─ .env.example          → (never commit your real .env!)\n  └─ README.md\n\n(frontend integration in Expo/React Native, not detailed here)",
    "skillsUsed": [
      "Node.js + Express: API design, environment config",
      "TypeScript: types, safety, modern async/await",
      "OpenAI API: prompt crafting, output parsing, rate limit handling",
      "Render: free, always-on cloud backend deployment",
      "REST integration: mobile-to-backend secure data flow"
    ],
    "challenges": [
      {
        "title": "OpenAI Key Safety",
        "details": ["Keeping secrets out of the frontend (never commit .env!)"],
        "methods": [
          "Use backend proxy to keep key hidden",
          "Store .env securely and gitignore"
        ]
      },
      {
        "title": "Networking and CORS",
        "details": ["Expo apps can’t call OpenAI directly—needed a backend"],
        "methods": ["Set up CORS properly in Express", "Use HTTPS endpoints"]
      },
      {
        "title": "Version and Deployment Quirks",
        "details": [
          "Express 5 types, tsconfig, and package version mismatches",
          "Render deployment: build command and PORT variable configuration"
        ],
        "methods": [
          "Careful version pinning",
          "Follow Render docs for deployment environment"
        ]
      },
      {
        "title": "Parsing GPT-4 Output",
        "details": [
          "GPT-4 sometimes returns code blocks or markdown—needed a robust cleaner"
        ],
        "methods": ["Sanitize responses", "Parse JSON safely and handle errors"]
      }
    ],
    "insights": "Real AI makes apps feel alive; cloud backend keeps things simple and shareable.",
    "insightsDetail": [
      "Real AI makes apps feel “alive”—users get different ideas each time",
      "Keeping the backend small (just one POST endpoint) means fewer bugs",
      "Cloud deployment opens up sharing—friends don’t need to run their own servers",
      "Prompt design is a superpower—tiny tweaks change style, tone, and fun",
      "The hardest part is always wiring up the first API call and parsing the AI’s reply!"
    ],
    "next": "Add images, user preferences, multi-language, and interactivity.",
    "nextDetail": [
      "Integrate DALL·E or other image generator for real AI outfit previews",
      "Save & favorite ideas per user (add database)",
      "Let users tweak prompts: “give me cozy pastel,” “what’s hot in Tokyo now?”",
      "Multi-language support for global friends",
      "Link AI outfits to real wardrobe items for mix-and-match"
    ],
    "finalThoughts": "AI Closet Style turned a basic fashion app into something surprising and delightful.",
    "finalThoughtsDetail": "AI Closet Style turned a basic fashion app into something surprising and delightful. Each day, new ideas—sometimes cute, sometimes totally out-there, always creative. Connecting Expo, Express, and OpenAI made me learn a lot about real-world AI app architecture (and how to debug npm type errors!). If you want to add live AI content to your app without blowing your key or your wallet, this pattern is hard to beat. Fashion should be fun, unpredictable, and a little bit magic. AI makes it possible.",
    "links": [
      {
        "label": "Backend Source on GitHub",
        "url": "https://github.com/joywong1228/ai-closet-backend"
      }
    ],
    "liveDemo": "https://www.youtube.com/embed/msFu_sFXgzs",

    "liveDemoNote": "Sorry, this blog is currently incomplete. I am focusing on adding all my projects first, then I will update the blog content."
  },
  {
    "id": "cancun-menu-app",
    "title": "CancunMenuApp – Interactive Resort Dining Explorer",
    "skills": [
      "React Native",
      "Expo",
      "Expo Speech",
      "AsyncStorage",
      "React Context"
    ],
    "previewImg": "/projectimg/cancun.jpeg",
    "published": "(add date)",
    "startDate": "2025-05-01",
    "endDate": "2025-06-01",
    "techStack": "React Native (Expo), Expo Speech, AsyncStorage, React Context",
    "duration": "2–3 weeks for MVP, still evolving",
    "intro": "CancunMenuApp is my personal take on solving a small but real travel frustration: browsing resort restaurant menus should be easy, visual, and accessible.",
    "introDetail": "Many resorts—including the beautiful Moon Palace Cancun—offer dozens of restaurants, but their menus are often buried in PDFs or outdated apps. I wanted to create a mobile-friendly experience where guests can swipe, listen, favorite, and preview dishes across venues in one elegant UI.",
    "goal": "Build an intuitive and interactive resort dining app.",
    "goalDetail": [
      "Build a smooth, intuitive restaurant menu viewer for Moon Palace Cancun",
      "Let users “favorite” dishes with animation and swipes",
      "Add Cantonese and English voice playback of dish names",
      "Auto-play and swipe through dish cards (kiosk-style)",
      "Organize menus by restaurant, category, and multilingual support",
      "Offline-first & usable without internet"
    ],
    "motivation": "Create a tactile and simple menu app that feels like flipping through cards at a fancy buffet.",
    "motivationDetail": "As someone who loves both travel and structured UI design, I wanted to turn my Moon Palace experience into a polished app. Most menu apps feel clunky or overloaded, so I focused on swipes, taps, and voice as main interactions. It was also a great way to improve my React Native skills.",
    "projectStructure": "/components\n  └─ MenuItemPreviewCard.tsx → popup swipeable card with audio + heart\n  └─ RestaurantPreviewCard.tsx → restaurant image card\n/screens\n  └─ MenuScreen.tsx → shows menu by restaurant\n  └─ FavoritesScreen.tsx → saved favorites from all menus\n  └─ RestaurantListScreen.tsx → explore restaurants visually\n/context\n  └─ FavoritesContext.tsx → global state management\n/data\n  └─ moonPalaceRestaurants.ts → metadata per restaurant\n  └─ menu-sun-01.ts → structured bilingual menu (JSON format)\n/assets\n  └─ photos of real dishes / logos / backgrounds",
    "skillsUsed": [
      "React Native (Expo): Core layout, navigation stack",
      "GestureResponder & PanResponder: Swipe left/right for menu cards",
      "Expo Speech: Play English/Cantonese dish names via button",
      "AsyncStorage + Context: Persist and manage favorite items",
      "Touchable feedback + toast messages: Show heart zoom, alerts like “End of list”",
      "JSX animation + logic for double-tap, long press, swipe bounds"
    ],
    "challenges": [
      {
        "title": "Edge Swipe Handling",
        "details": [
          "Users swiping beyond first/last card needed gentle boundary alerts like “This is the end.”"
        ],
        "methods": [
          "Implement toast alerts on boundary swipes",
          "Use gesture detection to prevent abrupt UI jumps"
        ]
      },
      {
        "title": "Expo Speech Quirks",
        "details": [
          "Cantonese voice support needed tweaking and language tagging (zh-HK)"
        ],
        "methods": [
          "Set appropriate language codes in Expo Speech API",
          "Test voice playback across devices"
        ]
      },
      {
        "title": "Heart Animation",
        "details": [
          "Animating the heart without breaking layout; double-tap conflicts"
        ],
        "methods": [
          "Separate animation and gesture logic",
          "Test with various tap speeds"
        ]
      },
      {
        "title": "Kiosk Mode",
        "details": [
          "Auto-play with swipe-only (no voice) needed a clean toggle and state reset on close"
        ],
        "methods": ["Create toggle controls and clear timers on modal close"]
      },
      {
        "title": "Context Syncing",
        "details": [
          "Ensuring Favorites persisted and updated live across screens"
        ],
        "methods": [
          "Use React Context for global favorites state",
          "Persist favorites to AsyncStorage"
        ]
      }
    ],
    "insights": [
      "UI polish matters: swipe feedback, modals, and toast alerts improve usability",
      "Designing structured menu JSON simplifies dynamic rendering",
      "Splitting MenuItemPreviewCard into visual and logic sections improves scalability",
      "Avoiding bloated UI kits keeps the app lightweight and custom-feeling"
    ],
    "next": [
      "Add search across all dishes (by keyword or ingredients)",
      "Add location-aware filters: show nearby venues in the resort",
      "Add image carousel for dishes with multiple photos",
      "Add voice settings: speed, tone, voice options",
      "Add dark mode toggle for night browsing",
      "Add export of favorites list to shareable PDF"
    ],
    "finalThoughts": "CancunMenuApp started as a fun side project but quickly became a polished tool I wish I had while on vacation. It blends UX, multilingual design, offline access, and interactivity.",
    "finalThoughtsDetail": "Whether you’re a guest planning dinner or a developer curious about React Native voice integration, there’s something here for you. Menus shouldn’t be boring—they should be swipeable, speakable, and lovable.",
    "links": [
      {
        "label": "Source on GitHub",
        "url": "https://github.com/joywong1228/cancunmenuapp"
      },
      {
        "label": "Submit a Menu PR",
        "url": "https://github.com/joywong1228/cancunmenuapp/pulls"
      }
    ],
    "liveDemo": "https://www.youtube.com/embed/3nFx6N3RAeE",
    "liveDemoNote": "Sorry, this blog is currently incomplete. I am focusing on adding all my projects first, then I will update the blog content."
  },
  {
    "id": "keep-track-of-weight",
    "title": "Keep Track Of Weight – A Simple iOS Weight Tracker",
    "skills": ["SwiftUI", "SwiftData"],
    "previewImg": "/assets/project/weight-tracker-preview.png",
    "published": "(add date)",
    "startDate": "2024-05-01",
    "endDate": "2024-05-03",
    "techStack": "SwiftUI, SwiftData",
    "duration": "2 days (MVP)",
    "intro": "After struggling to find a weight tracking app that’s simple, fast, and private, I decided to build my own using Apple’s newest frameworks—SwiftUI and SwiftData.",
    "introDetail": "“Keep Track Of Weight” is my answer to endless bloated fitness apps. It focuses on the essentials: log your weight daily, keep your data on-device, and visualize your progress over time.",
    "goal": "Practice modern SwiftUI and SwiftData; build a privacy-first MVP.",
    "goalDetail": [
      "Practice modern SwiftUI and SwiftData: Apply Apple’s latest declarative UI and persistence tools in a real project.",
      "Build an MVP: Just the basics—a way to add daily weights with timestamps and review your history.",
      "Privacy first: Store everything locally, with no accounts or ads.",
      "Lay a foundation: Make future features (charts, HealthKit, reminders) easy to add."
    ],
    "motivation": "Build a minimal, private weight tracker tailored to my needs.",
    "motivationDetail": "I’ve been working on building healthier habits, and daily weight tracking is a proven method for accountability. Most existing apps were overloaded or required signups, so I chose to build a focused, private solution and learn SwiftData.",
    "projectStructure": "App file (Keep_Track_Of_WeightApp.swift): Sets up the shared SwiftData model container.\nModel (Item.swift): Defines each weight entry with a timestamp (will add weight value soon).\nUI (ContentView.swift and others): Main views for adding and listing entries.\n(Optional): Unit/UI Tests with Xcode’s built-in testing targets.",
    "skillsUsed": [
      "SwiftUI: For the entire UI, navigation, and user interactions.",
      "SwiftData: Apple’s modern solution for local persistent storage.",
      "Xcode project structuring, app lifecycle, and model containers.",
      "Testing with Xcode’s default unit/UI test targets.",
      "Planning for extensibility and clean code."
    ],
    "challenges": [
      {
        "title": "Learning SwiftData",
        "details": [
          "SwiftData is new (WWDC 2023), so examples and docs are still sparse compared to Core Data."
        ],
        "methods": [
          "Read Apple’s WWDC sessions carefully.",
          "Experiment with model and container setups."
        ]
      },
      {
        "title": "Data Model Design",
        "details": [
          "Deciding initial schema: timestamp-only vs adding weight, notes, etc."
        ],
        "methods": [
          "Start simple and add fields later.",
          "Plan for schema migrations."
        ]
      },
      {
        "title": "Persistence Quirks",
        "details": [
          "Ensuring the model container is properly shared and persists data on device, not just in memory."
        ],
        "methods": [
          "Test saving and loading thoroughly.",
          "Debug lifecycle and container usage."
        ]
      },
      {
        "title": "UI Simplicity",
        "details": ["Avoiding feature creep before basics were solid."],
        "methods": [
          "Focus on core MVP features first.",
          "Use iterative design."
        ]
      }
    ],
    "insights": [
      "SwiftUI + SwiftData is productive with live previews and quick debugging.",
      "Getting an MVP done early is empowering for future work.",
      "Privacy is a strong selling point for niche apps."
    ],
    "next": [
      "Add actual weight input values (currently timestamp-only).",
      "Add simple line chart for visualizing progress.",
      "Integrate with HealthKit for syncing data.",
      "Add notifications for daily reminders.",
      "Polish UI, add dark mode and accessibility."
    ],
    "finalThoughts": "Building “Keep Track Of Weight” was a fun intro to modern iOS development. I’m eager to expand and improve it—feedback and contributions welcome!",
    "links": [
      {
        "label": "Source on GitHub",
        "url": "https://github.com/joywong1228/keep-track-of-weight"
      }
    ],
    "liveDemoNote": "Sorry, this blog is currently incomplete. I am focusing on adding all my projects first, then I will update the blog content."
  },
  {
    "id": "pyjama-flappy-meruem",
    "title": "Flappy Meruem – My First Complete Pygame Project",
    "skills": ["Python", "Pygame", "OOP", "Game Design"],
    "previewImg": "/projectimg/flappy-meruem-preview.png",
    "published": "(add date)",
    "techStack": "Python, Pygame",
    "duration": "A few weeks",
    "startDate": "2025-03-01",
    "endDate": "2025-03-21",
    "intro": "A pixelated, fast-paced side-scroller where you pilot the Chimera Ant King through endless pillars.",
    "introDetail": "Earlier this year, I took my Python skills to the next level by building a simple 2D game with Pygame. As a fan of Hunter x Hunter, I swapped the classic Flappy Bird for Meruem, adding pixel art UI and retro vibes.",
    "goal": "Learn Pygame basics and build a playable, fun game from scratch.",
    "goalDetail": [
      "Understand game loops, sprite handling, and collision detection.",
      "Build a playable Flappy Bird-style game with a unique character.",
      "Add custom pixel art and retro UI."
    ],
    "motivation": "Create a fun project that blends Python skills with personal interests.",
    "motivationDetail": "I wanted to go beyond tutorials and make a complete game inspired by one of my favorite anime characters. This was a chance to practice Python and have fun doing it.",
    "challenge": "Mastering sprite animation, physics, and game state management.",
    "challenges": [
      {
        "title": "Sprite Animation",
        "details": [
          "Smooth sprite cycling and frame speed control.",
          "Trigger animation only when appropriate."
        ],
        "methods": [
          "Cycle through frames based on time.",
          "Implement condition checks before animating."
        ]
      },
      {
        "title": "Physics & Gravity",
        "details": [
          "Adjust jump and gravity to feel right for a larger sprite."
        ],
        "methods": [
          "Tweak velocity and gravity constants.",
          "Test gameplay repeatedly."
        ]
      },
      {
        "title": "Pipe Generation",
        "details": ["Random but fair pipe gaps and positions."],
        "methods": [
          "Generate random gaps within set limits.",
          "Balance difficulty for replay value."
        ]
      },
      {
        "title": "Collision Detection",
        "details": ["Avoid false positives and sticking at edges."],
        "methods": [
          "Use Pygame's rect collision functions carefully.",
          "Test edge cases thoroughly."
        ]
      },
      {
        "title": "Game State Handling",
        "details": [
          "Manage transitions between ready, flying, and game over states."
        ],
        "methods": [
          "Implement a simple state machine pattern.",
          "Reset game on restart properly."
        ]
      }
    ],
    "skillsUsed": [
      "Python programming: list comprehensions, OOP with classes for Player, Pipe, Button.",
      "Pygame library: event handling, drawing, sprite groups.",
      "Basic animation: sprite cycling, scaling.",
      "Simple physics: gravity, velocity, collision logic.",
      "Game design: UI layout and restart logic.",
      "Debugging: trial-and-error with coordinate math and error messages."
    ],
    "insights": "Games are state machines; polish matters; small changes have big impact; Pygame is great for fundamentals.",
    "insightsDetail": [
      "Even simple games require multiple game states and smooth transitions.",
      "Tiny animation tweaks affect the feel dramatically.",
      "Changing sprites or UI details can refresh gameplay.",
      "Pygame exposes low-level game programming, which is great for learning."
    ],
    "next": "Refactor code, add sound effects, leaderboard, and possibly a mobile/web port.",
    "nextDetail": [
      "Separate game logic into modules.",
      "Add flap and crash sounds.",
      "Implement high score saving and leaderboard.",
      "Consider porting to mobile or web."
    ],
    "finalThoughts": "Building Flappy Meruem taught me Python, Pygame, and game feel. Proud to finish and hope it inspires others!",
    "finalThoughtsDetail": "This project was a great intro to game programming fundamentals. It was fun to blend my coding skills with personal interests. I’m excited to improve it and maybe share it with friends.",
    "links": [
      {
        "label": "Source on GitHub",
        "url": "https://github.com/joywong1228/flappy-meruem"
      }
    ],
    "liveDemoNote": "Sorry, this blog is currently incomplete. I am focusing on adding all my projects first, then I will update the blog content."
  },
  {
    "id": "tc-connect-platform",
    "title": "TC Connect Platform – A Community-Driven Tech Mentorship Hub",
    "skills": [
      "Web Development",
      "Responsive Design",
      "User Experience",
      "Project Management",
      "System Analysis"
    ],
    "previewImg": "/projectimg/tcconnect-main.png",
    "startDate": "2025-04-05",
    "techStack": "React, Node.js, REST APIs, Figma",
    "duration": "Semester-long team project",
    "intro": "TC Connect Platform aims to create a dynamic, web-based platform as a central hub for mentorship, job readiness, startup support, and AI upskilling.",
    "introDetail": "Designed to connect stakeholders like Advisors, Members, Founders, and Supporters, the platform offers role-specific dashboards, networking, and resources aligned with career and entrepreneurial goals. This project involved detailed analysis, use case and class diagrams, and team collaboration.",
    "goal": "Develop a responsive platform fostering community-driven growth",
    "goalDetail": [
      "Platform System:",
      "Use Firebase Auth for user roles and dashboards",
      "Build mentorship booking with Supabase/PostgreSQL",
      "Power job board with Supabase APIs",
      "Manage events with Supabase and Firebase Functions",
      "Handle messaging and notifications via Firebase and secure APIs",
      "-------------------",
      "Personal Learning:",
      "Figma design for responsive UI",
      "Use case and class diagrams for system analysis",
      "Gantt Chart for project management"
    ],
    "motivation": "Our first real client project found independently to unify resources and support Alberta’s tech community.",
    "motivationDetail": "Our first real client project, aimed to replace a limited site lacking accounts and interactivity with a scalable platform for personalized mentorship and career support in Alberta’s tech community.",
    "projectStructure": "Includes use case diagrams, use case descriptions, class and ER diagrams, and a detailed team constitution outlining roles and collaboration norms. Figma for UI design and project management tools like Gantt charts for task tracking.",
    "skillsUsed": [
      "System analysis and design",
      "Use case and class diagram modeling",
      "Team collaboration and project management",
      "Requirement gathering and client communication",
      "Responsive web design principles"
    ],
    "challenges": [
      {
        "title": "Limited Time and Resources",
        "details": [
          {
            "number": 1,
            "text": "Balancing project scope with semester deadlines and other coursework."
          },
          {
            "number": 2,
            "text": "Ensuring equal team contributions despite varying skills and availability."
          }
        ],
        "methods": [
          { "number": 1, "text": "Prioritizing core features for the MVP." },
          {
            "number": 2,
            "text": "Regular check-ins to track progress and redistribute tasks as needed."
          },
          {
            "number": 3,
            "text": "Using project management tools like Gantt Chart to visualize timelines and dependencies."
          }
        ]
      },
      {
        "title": "Unclear Requirements",
        "details": [
          {
            "text": "The team leader was the sole point of contact with the client, which sometimes led to incomplete or unclear requirements. Because it was a one-person communication channel, the leader couldn’t always anticipate all necessary questions or details. To address this, our team held internal meetings where we collectively reviewed the project scope and discussed ambiguities, allowing us to identify missing information and clarify expectations before proceeding."
          }
        ],
        "methods": [
          {
            "text": "Held several rounds of discussions within the team to clarify requirements, especially focusing on use case and class diagrams. We ensured all system aspects were covered and, by comparing with similar existing systems, confirmed that all necessary features for proper functionality were included."
          }
        ]
      }
    ],
    "insights": [
      "Early and detailed use case analysis prevents development roadblocks.",
      "Clear communication and role definition enhance team productivity.",
      "System design must balance user needs, security, and scalability."
    ],
    "next": ["The real website"],
    "finalThoughts": "TC Connect Platform provided a valuable learning opportunity to understand client needs clearly while balancing limited meeting time and team coordination challenges. Managing unclear requirements through multiple team discussions helped us align expectations. The project strengthened our skills in system analysis, effective communication, and collaboration under real-world constraints.",
    "teamConstitution": {
      "teamName": "Alberta Connector",
      "members": [
        {
          "name": "Kwan Ting Wong (Joy)",
          "role": "Standards Person",
          "skills": [
            "UI/UX design",
            "Front-end development",
            "Team collaboration"
          ]
        },
        {
          "name": "Jessie Tang",
          "role": "Leader",
          "skills": ["Client communication", "Submission coordination"]
        },
        {
          "name": "Dion Emary",
          "role": "Scribe/Facilitator",
          "skills": ["Meeting documentation", "Notes management"]
        },
        {
          "name": "Lam Dao",
          "role": "Peace Maker/Mediator",
          "skills": ["Conflict resolution", "Problem analysis"]
        }
      ]
    },
    "links": [
      {
        "label": "Figma Design Demo",
        "url": "https://www.figma.com/proto/53McdsBbF1yoeu4ta6bymS/CPSY301-Tech-connect?node-id=185-1132&starting-point-node-id=185%3A1132&t=Xy3rMWNkmMDKpfz4-1"
      },
      {
        "label": "Cilent's Original Website",
        "url": "https://techconnect.amgfoundation.ca/"
      }
    ],
    "liveDemo": "https://www.youtube.com/embed/CP5eDr9NSFg",
    "liveDemoNote": [
      "This project is a semester-long team effort",
      "The Figma design demo is at the end of the blog"
    ]
  },
  {
    "id": "appointment-manager",
    "title": "Hair Salon Appointment Manager System",
    "skills": ["Python", "OOP", "File I/O", "CLI"],
    "previewImg": "/projectimg/appointment-manager-preview.png",
    "published": "2024-12-13",
    "techStack": "Python, Pygame",
    "duration": "Several weeks across multiple project phases",
    "startDate": "2024-10-01",
    "endDate": "2024-12-13",
    "intro": "A command-line appointment management system for a hair salon to schedule, track, and manage client bookings.",
    "introDetail": "This project simulates a real-world booking system that tracks client names, phone numbers, appointment types, days, and times. It supports scheduling, canceling, changing appointments, and fee calculations.",
    "goal": "Build a functional CLI appointment system applying OOP concepts and file management.",
    "goalDetail": [
      "Create a weekly calendar with hourly appointment slots.",
      "Allow scheduling, canceling, and rescheduling of appointments.",
      "Search appointments by client name or day.",
      "Calculate fees by day and week.",
      "Save and load appointment data from files."
    ],
    "motivation": "To practice Python programming with classes, file I/O, and real-world logic in a manageable project.",
    "motivationDetail": "The project consolidates learning from Python basics to intermediate concepts like encapsulation and persistent storage. It also simulates practical business logic for a hair salon.",
    "projectStructure": "/appointment.py → Appointment class with properties and methods\n/main.py → Appointment management module handling scheduling, searching, cancellations, and fee calculations\n/appointments.csv → Stores appointment data",
    "skillsUsed": [
      "Python classes and encapsulation",
      "File reading and writing (CSV format)",
      "Input validation and CLI interaction",
      "List and loop management",
      "Basic algorithm design for search and scheduling"
    ],
    "challenges": [
      {
        "title": "Input Validation and Error Handling",
        "details": [
          "Ensuring user inputs (times, days, appointment types) are valid.",
          "Handling file I/O errors and invalid filenames."
        ],
        "methods": [
          "Implemented input loops with prompts for re-entry on errors.",
          "Used file existence checks and exception handling."
        ]
      },
      {
        "title": "Appointment Scheduling Logic",
        "details": [
          "Avoiding double bookings and managing appointment states.",
          "Handling cancellation and rescheduling with state updates."
        ],
        "methods": [
          "Checked slot availability before scheduling.",
          "Reset appointment slots upon cancellation or changes."
        ]
      },
      {
        "title": "Calculating Fees",
        "details": [
          "Mapping appointment types to fees accurately.",
          "Summing fees for specific days and the entire week."
        ],
        "methods": [
          "Used constants for appointment types and corresponding fees.",
          "Iterated over appointments with filtering by day."
        ]
      }
    ],
    "insights": [
      "OOP principles help organize code clearly and reuse logic.",
      "File persistence is essential for real-world applications beyond memory.",
      "Careful input validation greatly improves user experience."
    ],
    "next": [
      "Add GUI with Tkinter or PyQt for better usability.",
      "Implement appointment reminders and notifications.",
      "Add report exports and summary statistics."
    ],
    "finalThoughts": "This project strengthened my Python skills in classes, file I/O, and command-line interfaces, offering practical experience with business logic and state management.",
    "finalThoughtsDetail": "I’m proud to have built a usable appointment system from scratch. It taught me to think carefully about user input, program state, and persistence. Future improvements will focus on UI and richer features.",
    "links": [
      {
        "label": "Source Code on GitHub",
        "url": "https://github.com/yourusername/appointment-manager"
      }
    ],
    "liveDemoNote": "This project is a CLI application and does not have a live demo. This blog is not complete; I am focusing on adding all my projects first, then I will update the blog content."
  },
  {
    "id": "calgary-parking-app",
    "title": "ParkSense – A Real-Time MobileApp",
    "skills": [
      "React Native",
      "Expo",
      "API Integration",
      "Geolocation",
      "UI/UX"
    ],
    "previewImg": "/projectimg/parksense.png",
    "published": "2025-07-15",
    "techStack": "React Native (Expo), REST APIs, MapView, Location Services",
    "duration": "4 weeks (MVP)",
    "startDate": "2025-07-05",
    "endDate": "",
    "intro": "A mobile app providing real-time parking availability, rates, and navigation across Calgary parking lots.",
    "introDetail": "This app integrates Calgary’s open parking data APIs with React Native and Expo to show available parking spots, hourly rates, payment options, and operating hours. It helps users find and reserve parking efficiently.",
    "goal": "Build a user-friendly app that shows live parking info with location awareness and filtering.",
    "goalDetail": [
      "Fetch and display parking lot details including available spaces and rates",
      "Allow users to filter lots by price, distance, and features",
      "Integrate maps and navigation to guide users to parking",
      "API integration for real-time data"
    ],
    "motivation": "Solve the daily frustration of finding parking in a busy city with easy-to-use mobile tools.",
    "motivationDetail": "Parking in downtown Calgary is often frustrating and time-consuming. By leveraging public parking data and mobile tech, I wanted to create a tool that makes parking more accessible and less stressful for locals and visitors.",
    "challenge": "Working with real-time APIs, accurate location handling, and UI responsiveness.",
    "challenges": [
      {
        "title": "Finding a suitable parking API",
        "details": [
          "The current open data API for Calgary parking is not well-documented and has limited features, It only provides basic information like lot names, locations, and availability without detailed rates or payment options."
        ],
        "methods": ["Still thinking"]
      },
      {
        "title": "Geolocation and Map Integration",
        "details": [
          "Google Maps API offers comprehensive features but requires payment beyond free tier limits. Alternatives like Mapbox or OpenStreetMap are cost-effective but may have fewer features or less global coverage, so choosing the right API depends on budget and app needs."
        ],
        "methods": [
          "Use Expo Location and react-native-maps with appropriate permissions."
        ]
      },
      {
        "title": "UI Performance and Usability",
        "details": [
          "Hard to follow what is designed in the Figma because the features sometimes don’t match the actual UI when tested."
        ],
        "methods": [
          {
            "number": 1,
            "text": "Keep UI minimal and focused with clear feedback."
          },
          {
            "number": 2,
            "text": "Scarife some features for performance, like live updates every 5 minutes instead of real-time."
          }
        ]
      }
    ],
    "insights": [
      "Combining public data with location services empowers practical city apps.",
      "Efficient data caching and offline strategies greatly improve user experience.",
      "Minimal and responsive UI design is key for mobile usability."
    ],
    "next": ["Just keep building for now "],
    "finalThoughts": "Building Calgary Parking app was a rewarding challenge blending real-world data with user-centered mobile design. It’s a solid base for expanding smart city apps.",
    "links": [
      {
        "label": "Figma Preview",
        "url": "https://www.figma.com/proto/V6s4JXmihbHNh16BA7E8nO/Mobile-parking-app?node-id=66-114&p=f&t=V2pPhDcQ3fwCVjgc-1&scaling=scale-down&content-scaling=fixed&page-id=0%3A1&starting-point-node-id=66%3A114"
      }
    ],
    "liveDemoNote": "App is in MVP stage with real-time parking data but no payment or reservation features yet."
  },
  {
    "id": "movie-database-web",
    "title": "Movie Database",
    "skills": ["React", "Next.js", "Tailwind CSS", "Firebase Auth", "UI/UX"],
    "previewImg": "/assets/project/movie-db-preview.png",
    "published": "2025-07-15",
    "techStack": "Next.js 14, Firebase Authentication, Tailwind CSS, React State Management",
    "duration": "3 weeks for initial MVP",
    "startDate": "2025-07-15",
    "endDate": "",
    "intro": "A modern movie browsing web app built with React and Next.js, including Google login, search, and responsive movie UI.",
    "introDetail": [
      "This project provides a Netflix-style UI with movie rows, a banner, and login system. It’s designed to show how modern front-end frameworks, auth systems, and component reuse can combine into a clean entertainment web interface."
    ],
    "goal": "Practice React componentization and integrate Firebase Auth with a clean UI.",
    "goalDetail": [
      "Build reusable components like MovieCard, MovieRow, Banner, and NavBar",
      "Implement Google login/logout using Firebase Authentication",
      "Create a responsive UI that adapts to different screen widths",
      "Handle image loading errors with fallback and styling"
    ],
    "motivation": "Apply skills from React and Firebase into a fun, visual project for a portfolio-ready product.",
    "motivationDetail": "Instead of a dry to-do list, I wanted something fun and visual to showcase dynamic layouts, state management, and third-party integration — a movie site was the perfect theme.",
    "challenge": "Image fallback logic, horizontal row layout, and reusability.",
    "challenges": [
      {
        "title": "Dynamic Layout and Image Fallback",
        "details": [
          "Ensuring broken or empty image URLs show a fallback",
          "Maintaining consistent layout across devices with flex and scroll"
        ],
        "methods": [
          "Used <img onError> to set fallback on runtime failure",
          "Refined Tailwind layout and tested responsiveness with flex-wrap"
        ]
      },
      {
        "title": "Authentication Flow",
        "details": [
          "Integrating Firebase Auth with Google Sign-In",
          "Redirecting to login and home on auth state changes"
        ],
        "methods": [
          "Used Firebase SDK + custom auth context",
          "Router push logic on logout/login success"
        ]
      },
      {
        "title": "Reusable Design & NavBar Placement",
        "details": [
          "Ensuring the NavBar is visible across all pages",
          "Handling layout glitches with client/server components"
        ],
        "methods": [
          "Created separate NavBar component and manually included it in pages",
          "Used conditional rendering and user context for dynamic behavior"
        ]
      }
    ],
    "insights": [
      "Image loading errors need more robust handling than just missing URLs.",
      "Flexbox + scroll is powerful but requires testing across screen sizes.",
      "Auth and navigation should be planned early for cleaner flow."
    ],
    "next": [
      "Fetch real movie data from TMDB API",
      "Add user favorites and watchlist",
      "Make banners dynamic with trailers or overviews"
    ],
    "finalThoughts": "This app was an effective playground for mastering state, layout, and auth in a single page React app. It’s both functional and visually impressive for portfolio showcase.",
    "liveDemoNote": [
      "This app is still under development and hosted locally.",
      "I will deploy it and update the live demo link soon."
    ]
  },
  {
    "id": "signup-auth-enhancements",
    "title": "Simply Sign-up and Landign App",
    "skills": [
      "React Native",
      "Expo",
      "Authentication",
      "UX/UI",
      "Firebase",
      "Supabase"
    ],
    "published": "2025-07-19",
    "liveDemo": "https://www.youtube.com/embed/NSwx5qn3ARw",
    "techStack": "React Native (Expo), Firebase Auth, Supabase, React Navigation",
    "duration": "1 week",
    "startDate": "2025-07-17",
    "endDate": "2025-07-19",
    "previewImg": "/projectimg/signup.png",
    "intro": "Created a completely functional sign-up and authentication app with improved UX and bug fixes.",
    "goal": "Fix key UX issues in sign-up and authentication process, improve session handling, and enhance UI responsiveness.",
    "motivation": "It is a class assignemnt",
    "challenges": [
      {
        "title": "My Thoughts",
        "details": [
          "At first, I thought this assignment would be easy, but it turned out to be much more challenging than expected. I needed to configure Supabase security rules properly to allow database fetching. Although I set the insert rule correctly, I forgot to add the fetch rule, which caused me to spend an entire day debugging.",
          "Additionally, several small UI issues were initially overlooked, such as needing the keyboard to dismiss when tapping outside inputs, and ensuring the screen remains fully visible when the keyboard is open."
        ]
      },
      {
        "title": "Keyboard and Layout Handling",
        "details": [
          "App layout did not adjust properly when keyboard opened, blocking input fields."
        ],
        "methods": [
          "Added KeyboardAvoidingView and ScrollView to manage keyboard overlay.",
          "Implemented tap-to-dismiss keyboard behavior."
        ]
      },
      {
        "title": "Password Visibility and Input UX",
        "details": [
          "Password input lacked visibility toggle causing user frustration.",
          "Form submission feedback was unclear."
        ],
        "methods": [
          "Added password show/hide toggle icon.",
          "Updated success alert with explicit “Yes” and “Stay” options."
        ]
      },
      {
        "title": "Session and Routing Fixes",
        "details": [
          "Auto-login after sign-up created confusion.",
          "Landing page did not fetch user full name properly."
        ],
        "methods": [
          "Forced sign-out after sign-up to prevent auto-login.",
          "Refined session check logic and routing for /signin and /landing routes.",
          "Pulled full name from user_details table and displayed on landing screen."
        ]
      }
    ],

    "finalThoughts": "This update significantly improved the authentication experience by addressing critical UI bugs and session management issues, making the app more polished and user-friendly.",
    "links": [
      {
        "label": "Source Code on GitHub",
        "url": "https://github.com/joywong1228/Mobile-Assignment-4"
      }
    ]
  },
  {
    "id": "head-up-game",
    "title": "Head Up – Hong Kong Version",
    "skills": ["React Native", "Expo", "Game Logic", "UI/UX"],
    "previewImg": "/projectimg/head-up.png",
    "published": "2025-07-21",
    "techStack": "React Native (Expo), JavaScript",
    "duration": "2 day",
    "startDate": "2025-07-21",
    "endDate": "2025-07-21",
    "intro": "A mobile game where players guess words displayed on their forehead by reading clues from friends.",
    "introDetail": "Head Up is a fun, social guessing game inspired by the classic party game. Players hold their device to their forehead to see a word or phrase while friends give hints to help them guess correctly before time runs out.",
    "goal": "Build an interactive and intuitive game experience leveraging React Native and Expo.",
    "goalDetail": [
      "Implement a timer and score tracking system.",
      "Design a simple, clean UI for gameplay and navigation.",
      "Allow easy word category selection.",
      "Handle game start, pause, and end states."
    ],
    "motivation": "During a family gathering in Canada, I realized many words were unfamiliar to me as a Hong Konger, so I wanted to create an app that feels personal and relatable.",
    "motivationDetail": "While spending time with my family in Canada, I noticed that, as someone from Hong Kong, there were many words and phrases I didn’t know or understand. This inspired me to build an app tailored for people like us—something familiar, fun, and meaningful that connects our shared experiences.",
    "challenges": [
      {
        "title": "My Thoughts",
        "details": [
          "This project turned out to be relatively straightforward compared to others, as I was able to reference and build upon an existing version of the Head Up game. While it didn’t present many unique challenges, this allowed me to focus on understanding the core mechanics and improving my implementation skills."
        ]
      }
    ],
    "insights": "React Native provides a fast and flexible platform for simple game development with native feel.",
    "insightsDetail": [
      "Using React hooks makes timer and state handling straightforward.",
      "A minimalist UI helps keep gameplay focused and accessible.",
      "Testing on real devices uncovered UI tweaks needed for usability."
    ],
    "next": [
      "Add multiplayer support via Bluetooth or internet.",
      "Include more word categories and difficulty levels.",
      "Implement sound effects and animations for better feedback."
    ],
    "finalThoughts": "Building Head Up was a rewarding experience that combined UI design, game logic, and React Native skills. It’s a fun app to play with friends and a solid foundation for more complex game features.",
    "finalThoughtsDetail": "This project enhanced my understanding of React Native fundamentals and firebase cloud, while creating a delightful user experience. I’m excited to continue expanding its features and polish.",
    "links": [
      {
        "label": "Source on GitHub",
        "url": "https://github.com/joywong1228/heas_up_hong_kong_version"
      }
    ],
    "liveDemo": "https://heas-up-hong-kong-version.vercel.app"
  }
]
